<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Blog Network</title>
<style>
body {
  margin:0; font-family:Arial,sans-serif;
  background:#f0f4ff url('https://www.transparenttextures.com/patterns/tileable-wood-print.png') repeat;
  color:#000080; user-select:none;
}
header {
  background:linear-gradient(90deg,#3399ff,#9966ff);
  padding:20px 30px; box-shadow:0 3px 6px rgba(0,0,0,0.3);
  display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap;
}
.logo-container { display:flex; align-items:center; gap:15px; }
.logo { font-size:36px; color:#fff; font-weight:bold; }
.tagline { font-size:18px; color:#ffe066; font-style:italic; font-weight:bold; text-shadow:1px 1px 0 #000033; }
nav { display:flex; gap:10px; align-items:center; margin-top:10px; flex-wrap:wrap; }

button.filter-btn {
  background:#ffcc00; border:2px solid #000080; border-radius:3px;
  padding:8px 14px; font-weight:bold; font-size:12px; cursor:pointer;
  color:#000080; box-shadow:1px 1px 0 #333; transition:background 0.2s; user-select:none;
}
button.filter-btn:hover { background:#ffff66; }
button.filter-btn.active { background:#ffff99; border-color:#330066; box-shadow:2px 2px 4px #660099; }

#profile-btn, #notif-btn {
  background:#ffcc00; border:2px solid #000080; border-radius:3px;
  padding:8px 10px; font-weight:bold; font-size:14px; cursor:pointer;
  color:#000080; box-shadow:1px 1px 0 #333; transition:background 0.2s;
}
#profile-btn:hover, #notif-btn:hover { background:#ffff66; }

#notif-wrap { position:relative; }
#notif-count {
  position:absolute; top:-6px; right:-6px; background:#e02424; color:#fff;
  border-radius:10px; padding:2px 6px; font-size:11px; display:none;
}
#notif-panel {
  position:absolute; right:0; top:42px; width:280px; max-height:320px; overflow:auto;
  background:#ffffff; border:2px solid #9966ff; box-shadow:0 6px 14px rgba(0,0,0,0.25);
  border-radius:6px; display:none; z-index:10;
}
.notif-item {
  padding:10px; border-bottom:1px solid #eee; font-size:13px;
}
.notif-item.unread { background:#f5f0ff; font-weight:bold; }
.notif-empty { padding:14px; text-align:center; color:#555; font-size:13px; }

main {
  max-width:700px; margin:25px auto; padding:10px 20px;
  background:#ffffffcc; border:3px solid #3399ff;
  box-shadow:0 4px 10px rgba(0,0,0,0.2); border-radius:6px; min-height:300px;
}
form#post-form {
  max-width:700px; margin:0 auto 25px auto; background:#ffffffcc;
  padding:15px 20px; border:3px solid #9966ff; border-radius:6px;
  box-shadow:0 4px 8px rgba(153,102,255,0.5); display:flex; flex-direction:column;
}
input#username, textarea#post-content {
  width:100%; padding:8px; font-size:14px; border:2px solid #9966ff; border-radius:4px;
}
textarea#post-content { min-height:60px; resize:vertical; }
button#submit-post {
  margin-top:8px; background:#9966ff; border:none;
  padding:8px 16px; color:white; font-weight:bold;
  border-radius:4px; cursor:pointer; align-self:flex-end; transition:background 0.3s;
}
button#submit-post:hover { background:#7a3fcc; }

.post {
  border:2px inset #99ccff; background:#e6f0ff; padding:15px; margin-bottom:20px;
  font-size:13px; font-family:'Courier New', monospace;
  box-shadow:1px 1px 0 #99ccff; display:flex; align-items:center; gap:10px;
}
.post img { width:40px; height:40px; border-radius:50%; object-fit:cover; cursor:pointer; }
.post-content { display:flex; flex-direction:column; }
.post-content .author a { text-decoration:none; color:#000080; font-weight:bold; cursor:pointer; }
.post-content .author a:hover { text-decoration:underline; }

footer { text-align:center; margin:20px auto; font-size:12px; font-family:'Courier New', monospace; color:#333; }
</style>
</head>
<body>

<header>
  <div class="logo-container">
    <div class="logo">THE BLOG NETWORK</div>
    <div class="tagline">Chat with others!</div>
  </div>
  <nav>
    <div style="display:flex; gap:10px; align-items:center;">
      <button class="filter-btn active" data-filter="friends">Friends</button>
      <button class="filter-btn" data-filter="unseen">Unseen</button>
      <button class="filter-btn" data-filter="public">Public</button>
    </div>

    <!-- Notifications + Profile -->
    <div style="display:flex; gap:10px; align-items:center;">
      <div id="notif-wrap">
        <button id="notif-btn" title="Notifications">ðŸ””</button>
        <span id="notif-count">0</span>
        <div id="notif-panel"></div>
      </div>
      <a href="profile.html"><button id="profile-btn" title="Your Profile">ðŸ‘¤</button></a>
    </div>
  </nav>
</header>

<form id="post-form">
  <input type="text" id="username" placeholder="Your username" />
  <textarea id="post-content" placeholder="Write your post here..."></textarea>
  <button type="submit" id="submit-post">Post</button>
</form>

<main id="feed"></main>

<footer>
  <em>EST. 2025 CREATED BY friend_alpha</em>
</footer>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
// ----------------------
// Stable unique userId
// ----------------------
let currentUserID = localStorage.getItem('userId');
if (!currentUserID) {
  currentUserID = 'user_' + Date.now() + '_' + Math.floor(Math.random()*1000);
  localStorage.setItem('userId', currentUserID);
}

// ----------------------
// Firebase init
// ----------------------
const firebaseConfig = {
  apiKey:"AIzaSyBGNJwqrVv4lMPBTXiwwhv81cxCrIYF6V0",
  authDomain:"the-blog-network.firebaseapp.com",
  projectId:"the-blog-network",
  storageBucket:"the-blog-network.appspot.com",
  messagingSenderId:"857847462134",
  appId:"1:857847462134:web:a22e9a6467a230632b94d7"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// ----------------------
// UI refs
// ----------------------
const buttons = document.querySelectorAll('.filter-btn');
const feed = document.getElementById('feed');
const form = document.getElementById('post-form');
const textarea = document.getElementById('post-content');
const usernameInput = document.getElementById('username');
const notifBtn = document.getElementById('notif-btn');
const notifCount = document.getElementById('notif-count');
const notifPanel = document.getElementById('notif-panel');

let currentFilter = 'friends';

// Load username from localStorage
if(localStorage.getItem('username')) usernameInput.value = localStorage.getItem('username');

// ----------------------
// Bad words filter
// ----------------------
const badWords=['nigger','retard','shit','nigga','fuck','bitch','bastard','crap','douche','dick','cunt','cock','pussy','tits','dickhead','slut','whore','motherfucker'];
function sanitizeText(text){let s=text;badWords.forEach(w=>{s=s.replace(new RegExp(`\\b${w}\\b`,'gi'),'****')});return s;}

// ----------------------
// Time helper
// ----------------------
function formatTimestamp(date){
  const now=new Date();
  const diffMs=now-date;
  const diffMins=Math.floor(diffMs/60000);
  if(diffMins<1) return 'just now';
  if(diffMins===1) return '1 minute ago';
  if(diffMins<60) return `${diffMins} minutes ago`;
  const diffHrs=Math.floor(diffMins/60);
  if(diffHrs===1) return '1 hour ago';
  if(diffHrs<24) return `${diffHrs} hours ago`;
  const diffDays=Math.floor(diffHrs/24);
  if(diffDays===1) return '1 day ago';
  return `${diffDays} days ago`;
}

// -------------------------------------
// Filter buttons (friends/public/unseen)
// -------------------------------------
buttons.forEach(btn => {
  btn.addEventListener('click', ()=>{
    buttons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentFilter = btn.getAttribute('data-filter');
    applyCurrentFilter();
  });
});

// -------------------------------------
// FRIENDS: store & listen
// Structure: users/{uid}/friends/{friendUid} => {status:"accepted", since:Timestamp}
// -------------------------------------
let friendIds = new Set(); // accepted friends of current user

function subscribeFriends() {
  db.collection('users').doc(currentUserID).collection('friends')
    .where('status','==','accepted')
    .onSnapshot((snap)=>{
      friendIds = new Set();
      snap.forEach(doc=>friendIds.add(doc.id));
      // Always include yourself so your posts appear in Friends
      friendIds.add(currentUserID);
      applyCurrentFilter();
    });
}
subscribeFriends();

// -------------------------------------
// POSTS: live listener (still reads all,
// then we filter client-side to keep it simple)
// -------------------------------------
let cachedPosts = []; // {id, data, userData}

const userCache = {}; // authorId -> user doc
function fetchMissingUsers(authorIds) {
  const missing = authorIds.filter(id => !userCache[id]);
  if (missing.length === 0) return Promise.resolve();
  // Firestore 'in' limit: keep it simple/batch if needed
  const chunks = [];
  while (missing.length) chunks.push(missing.splice(0,10));
  return Promise.all(chunks.map(list =>
    db.collection('users')
      .where(firebase.firestore.FieldPath.documentId(), 'in', list)
      .get()
      .then(s => s.forEach(u => userCache[u.id] = u.data() || {}))
  ));
}

function renderFeed() {
  feed.innerHTML = '';
  cachedPosts.forEach(p => {
    const post = p.data;
    const authorId = post.authorId || 'friend_alpha';
    const userData = userCache[authorId] || { username: authorId, avatarURL: 'https://via.placeholder.com/40' };

    const article = document.createElement('article');
    article.className='post';
    article.dataset.type = post.type || 'public';
    article.dataset.author = authorId;

    article.innerHTML = `
      <img src="${userData.avatarURL || 'https://via.placeholder.com/40'}" alt="avatar" class="profile-link" data-userid="${authorId}">
      <div class="post-content">
        <div class="author">
          <a href="profile.html?user=${encodeURIComponent(authorId)}">${userData.username || authorId}</a>
        </div>
        <div class="timestamp">${post.timestamp?formatTimestamp(post.timestamp.toDate()):''}</div>
        <div class="content">${post.content}</div>
      </div>
    `;
    feed.appendChild(article);

    article.querySelectorAll('.profile-link').forEach(img=>{
      img.addEventListener('click', ()=>{
        const uid = img.dataset.userid;
        window.location.href = `profile.html?user=${encodeURIComponent(uid)}`;
      });
    });
  });

  applyCurrentFilter();
}

function applyCurrentFilter() {
  const posts = feed.querySelectorAll('.post');
  posts.forEach(el=>{
    const type = el.dataset.type || 'public';
    const author = el.dataset.author || '';
    let show = true;

    if (currentFilter === 'public') {
      show = (type === 'public');
    } else if (currentFilter === 'friends') {
      // Only show if author is in your accepted friends (or you)
      show = friendIds.has(author);
    } else if (currentFilter === 'unseen') {
      // Simple placeholder: show public posts you didn't author
      show = (type === 'public' && author !== currentUserID);
    }

    el.style.display = show ? 'flex' : 'none';
  });
}

db.collection('posts').orderBy('timestamp','desc').onSnapshot(async (snapshot)=>{
  cachedPosts = snapshot.docs.map(d => ({ id: d.id, data: d.data() }));
  const authors = [...new Set(cachedPosts.map(p => p.data.authorId).filter(Boolean))];
  await fetchMissingUsers(authors);
  renderFeed();
});

// -------------------------------------
// Notifications (very simple)
// Structure: users/{uid}/notifications/{notifId} => {text, type, createdAt, read:false}
// -------------------------------------
let notifUnreads = 0;

function subscribeNotifications() {
  db.collection('users').doc(currentUserID).collection('notifications')
    .orderBy('createdAt','desc')
    .onSnapshot((snap)=>{
      const items = [];
      notifUnreads = 0;
      snap.forEach(doc=>{
        const n = doc.data();
        items.push({ id: doc.id, ...n });
        if (!n.read) notifUnreads++;
      });
      drawNotifications(items);
    });
}
subscribeNotifications();

function drawNotifications(items) {
  // Count bubble
  if (notifUnreads > 0) {
    notifCount.textContent = String(notifUnreads);
    notifCount.style.display = 'inline-block';
  } else {
    notifCount.style.display = 'none';
  }

  // Panel
  notifPanel.innerHTML = '';
  if (items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'notif-empty';
    empty.textContent = 'No notifications yet.';
    notifPanel.appendChild(empty);
    return;
  }

  items.forEach(n=>{
    const div = document.createElement('div');
    div.className = 'notif-item' + (n.read ? '' : ' unread');
    const when = n.createdAt ? formatTimestamp(n.createdAt.toDate()) : 'just now';
    div.innerHTML = `<div>${n.text || '(no text)'}<div style="font-size:11px;color:#555;margin-top:4px;">${when}</div></div>`;
    div.addEventListener('click', async ()=>{
      // mark single as read
      await db.collection('users').doc(currentUserID).collection('notifications').doc(n.id).set({ read:true }, { merge:true });
    });
    notifPanel.appendChild(div);
  });
}

notifBtn.addEventListener('click', async ()=>{
  // toggle panel
  notifPanel.style.display = (notifPanel.style.display === 'block') ? 'none' : 'block';

  // mark all visible as read
  if (notifPanel.style.display === 'block') {
    const snap = await db.collection('users').doc(currentUserID).collection('notifications')
      .where('read','==',false).get();
    const batch = db.batch();
    snap.forEach(doc=> batch.set(doc.ref, { read:true }, { merge:true }));
    await batch.commit();
  }
});

// Click outside to close notifications
document.addEventListener('click',(e)=>{
  const wrap = document.getElementById('notif-wrap');
  if (!wrap.contains(e.target)) notifPanel.style.display = 'none';
});

// -------------------------------------
// Handle new post (unchanged, still uses "posts" collection)
// -------------------------------------
form.addEventListener('submit', async e=>{
  e.preventDefault();
  const content = textarea.value.trim();
  if(!content) return alert('Please write something before posting!');

  const newUsername = (usernameInput.value.trim() || 'friend_alpha');
  localStorage.setItem('username', newUsername);

  try {
    // Ensure user doc exists/updated for avatar + username
    const userDocRef = db.collection('users').doc(currentUserID);
    const userDoc = await userDocRef.get();
    const existingData = userDoc.exists ? userDoc.data() : {};

    // If username already used by a different user, block
    const usernameCheck = await db.collection('users')
      .where('username', '==', newUsername)
      .get();
    if(!userDoc.exists && !usernameCheck.empty){
      return alert('Username already taken! Choose another.');
    }

    await userDocRef.set({
      username: newUsername,
      avatarURL: existingData.avatarURL || 'https://via.placeholder.com/40'
    }, { merge: true });

    // Add post to main feed (respect currentFilter as "type" meta only)
    await db.collection('posts').add({
      authorId: currentUserID,
      content: sanitizeText(content),
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      type: currentFilter,
      key: "MY_SECRET_KEY"
    });

    textarea.value='';
  } catch(err) {
    alert('Error posting: '+err.message);
  }
});
</script>
</body>
</html>
